
太棒了！在Unity中制作一个带“撤销/重做”（Undo/Redo）功能的关卡编辑器是一个非常有价值且能极大提升开发效率的功能。这在几乎所有内容创作工具（如Photoshop, Blender, Word）中都是标配。

实现撤销/重做功能的核心思想是：**将用户的每一个可逆操作，抽象成一个“命令”（Command），然后用两个栈（Stack）来管理这些命令。**

*   一个栈用于存放已执行的操作，我们称之为 **“撤销栈”（Undo Stack）**。
*   另一个栈用于存放已撤销的操作，我们称之为 **“重做栈”（Redo Stack）**。

下面我将详细解释如何设计和实现这个系统。

---

### 一、 核心设计：命令模式 (Command Pattern)

命令模式是实现撤销/重做功能最经典、最有效的设计模式。

1.  **定义一个命令接口（`ICommand`）**：
    所有具体的操作（如移动物体、创建物体、修改颜色等）都将实现这个接口。这个接口必须包含两个核心方法：
    *   `Execute()`: 执行这个操作。
    *   `Undo()`: 撤销这个操作。

    ```csharp
    public interface ICommand
    {
        void Execute(); // 执行
        void Undo();    // 撤销
    }
    ```

2.  **创建具体的命令类（Concrete Commands）**：
    为你的编辑器中的每一种操作创建一个具体的命令类。

    **示例1：移动物体的命令 `MoveCommand`**

    这个命令需要记录移动的物体、移动前的位置和移动后的位置。

    ```csharp
    using UnityEngine;

    public class MoveCommand : ICommand
    {
        private Transform _target;      // 目标物体
        private Vector3 _startPosition; // 移动前的位置
        private Vector3 _endPosition;   // 移动后的位置

        public MoveCommand(Transform target, Vector3 startPosition, Vector3 endPosition)
        {
            _target = target;
            _startPosition = startPosition;
            _endPosition = endPosition;
        }

        // 执行操作：将物体移动到目标位置
        public void Execute()
        {
            _target.position = _endPosition;
        }

        // 撤销操作：将物体移回原始位置
        public void Undo()
        {
            _target.position = _startPosition;
        }
    }
    ```

    **示例2：创建物体的命令 `CreateObjectCommand`**

    这个命令需要记录被创建的物体。

    ```csharp
    using UnityEngine;

    public class CreateObjectCommand : ICommand
    {
        private GameObject _createdObject; // 被创建的物体
        private Vector3 _position;          // 创建的位置
        private GameObject _prefab;         // 用于创建的预制体

        public CreateObjectCommand(GameObject prefab, Vector3 position)
        {
            _prefab = prefab;
            _position = position;
        }

        // 执行操作：实例化物体
        public void Execute()
        {
            // 如果是第一次执行，就创建物体
            if (_createdObject == null)
            {
                _createdObject = Object.Instantiate(_prefab, _position, Quaternion.identity);
            }
            // 如果是重做，就重新激活它
            else
            {
                _createdObject.SetActive(true);
            }
        }

        // 撤销操作：销毁或隐藏物体
        public void Undo()
        {
            // 为了性能，通常选择隐藏而不是销毁，因为重做时无需重新实例化
            _createdObject.SetActive(false);
        }
    }
    ```

    **示例3：删除物体的命令 `DeleteObjectCommand`**

    这本质上是 `CreateObjectCommand` 的反向操作。

    ```csharp
    using UnityEngine;

    public class DeleteObjectCommand : ICommand
    {
        private GameObject _targetObject;

        public DeleteObjectCommand(GameObject target)
        {
            _targetObject = target;
        }
  
        public void Execute()
        {
            _targetObject.SetActive(false);
        }

        public void Undo()
        {
            _targetObject.SetActive(true);
        }
    }

    ```

---

### 二、 管理器实现：`CommandHistory`

接下来，我们需要一个管理器来处理命令的执行、撤销和重做。

1.  **创建 `CommandHistory` 类**：
    这个类将包含我们的“撤销栈”和“重做栈”。

    ```csharp
    using System.Collections.Generic;

    public class CommandHistory
    {
        private Stack<ICommand> _undoStack = new Stack<ICommand>();
        private Stack<ICommand> _redoStack = new Stack<ICommand>();

        // 执行一个新命令
        public void ExecuteCommand(ICommand command)
        {
            command.Execute();          // 首先执行命令
            _undoStack.Push(command);   // 将命令压入撤销栈
            _redoStack.Clear();         // 一旦有新操作，清空重做栈
        }

        // 撤销上一个操作
        public void Undo()
        {
            if (_undoStack.Count > 0)
            {
                ICommand command = _undoStack.Pop(); // 从撤销栈中取出命令
                command.Undo();                      // 执行撤销
                _redoStack.Push(command);            // 将命令压入重做栈
            }
        }

        // 重做上一个被撤销的操作
        public void Redo()
        {
            if (_redoStack.Count > 0)
            {
                ICommand command = _redoStack.Pop(); // 从重做栈中取出命令
                command.Execute();                   // 重新执行
                _undoStack.Push(command);            // 将命令压回撤销栈
            }
        }
      
        // 清空历史记录 (例如：加载新关卡时)
        public void Clear()
        {
            _undoStack.Clear();
            _redoStack.Clear();
        }
    }
    ```

---

### 三、 在编辑器中集成

现在，我们将这个系统集成到你的关卡编辑器逻辑中。

1.  **创建 `LevelEditorManager`**：
    这个脚本是你的编辑器主控制器。

    ```csharp
    using UnityEngine;

    public class LevelEditorManager : MonoBehaviour
    {
        private CommandHistory _commandHistory = new CommandHistory();
        private Transform _selectedObject; // 当前选中的物体
        private Vector3 _dragStartPosition; // 拖拽物体的起始位置

        void Update()
        {
            // 监听键盘输入，用于撤销和重做
            // Windows: Ctrl+Z, Ctrl+Y
            // macOS: Command+Z, Command+Shift+Z (这里用Ctrl+Y代替)
            if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.LeftCommand))
            {
                if (Input.GetKeyDown(KeyCode.Z))
                {
                    _commandHistory.Undo();
                }
                else if (Input.GetKeyDown(KeyCode.Y))
                {
                    _commandHistory.Redo();
                }
            }

            // 处理用户输入，例如鼠标点击选择、拖拽物体等
            HandleMouseInput();
        }
      
        private void HandleMouseInput()
        {
            // --- 示例：拖拽移动物体 ---
            if (Input.GetMouseButtonDown(0))
            {
                // 通过射线检测等方式选中物体
                // _selectedObject = ...;
                if (_selectedObject != null)
                {
                    _dragStartPosition = _selectedObject.position;
                }
            }
      
            if (Input.GetMouseButtonUp(0))
            {
                if (_selectedObject != null)
                {
                    Vector3 endPosition = _selectedObject.position;
              
                    // 如果位置发生了变化，创建一个MoveCommand
                    if (Vector3.Distance(_dragStartPosition, endPosition) > 0.01f) // 加一个阈值避免误操作
                    {
                        ICommand moveCommand = new MoveCommand(_selectedObject, _dragStartPosition, endPosition);
                        // 注意：这里不要直接执行，而是通过CommandHistory来执行
                        // 我们需要将移动操作本身也放入CommandHistory的记录中
                        // 所以正确的做法是：在拖拽结束后，把物体位置先复原，再由ExecuteCommand来设定最终位置
                        _selectedObject.position = _dragStartPosition; // 复原
                        _commandHistory.ExecuteCommand(moveCommand); // 执行并记录
                    }
                }
                _selectedObject = null;
            }
        }

        // --- 示例：创建物体的按钮回调 ---
        public void OnCreateObjectButtonPressed(GameObject prefabToCreate)
        {
            // 假设在鼠标位置创建
            Vector3 createPosition = GetMouseWorldPosition(); 
            ICommand createCommand = new CreateObjectCommand(prefabToCreate, createPosition);
            _commandHistory.ExecuteCommand(createCommand);
        }

        // --- 示例：删除物体的按钮回调 ---
        public void OnDeleteObjectButtonPressed(GameObject objectToDelete)
        {
            ICommand deleteCommand = new DeleteObjectCommand(objectToDelete);
            _commandHistory.ExecuteCommand(deleteCommand);
        }
      
        // 加载新关卡时清除历史记录
        public void LoadLevel()
        {
           // ... 加载关卡逻辑 ...
           _commandHistory.Clear();
        }

        private Vector3 GetMouseWorldPosition()
        {
            // 实现获取鼠标在世界坐标中的位置
            // ...
            return Vector3.zero;
        }
    }
    ```

---

### 四、 进阶与优化

1.  **复合命令（Composite Command）**:
    有时候一个操作可能由多个子操作组成（例如，同时移动多个物体）。你可以创建一个 `CompositeCommand`，它内部持有一个 `List<ICommand>`。它的 `Execute` 和 `Undo` 方法会遍历列表，并调用所有子命令的相应方法。

2.  **节流/合并命令（Throttling/Merging Commands）**:
    对于像拖拽、调整大小、旋转这样的连续操作，如果你在每一帧都创建一个新命令，撤销栈会瞬间爆炸。
    *   **解决方案**：只在操作开始时（`MouseButtonDown`）记录初始状态，在操作结束时（`MouseButtonUp`）创建一个命令，记录从开始到结束的整个变化。这正是上面 `HandleMouseInput` 示例所做的事情。
    *   **对于滑动条(Slider)**：你可以在用户开始拖动时记录初始值，在释放滑动条时，根据最终值创建一个命令。

3.  **性能考虑**:
    *   对于创建/删除操作，使用 `SetActive(true/false)` 而不是 `Instantiate/Destroy` 会快得多，也能避免一些引用丢失的问题。
    *   如果关卡数据非常庞大，命令对象本身可能会占用大量内存。可以考虑一些轻量级的数据结构来存储状态，而不是直接引用`GameObject`或`Component`。

4.  **与Unity Editor的 Undo/Redo 系统集成**:
    如果你是在制作一个**Editor扩展窗口**（`EditorWindow`）而不是**运行时**的编辑器，那么Unity已经提供了一套强大的Undo系统。
    *   使用 `Undo.RecordObject(objectToRecord, "Description of action")` 来记录一个对象在发生变化前的状态。
    *   当发生变化后，Unity会自动处理撤销和重做。
    *   例如：`Undo.RecordObject(transform, "Move Object"); transform.position = newPosition;`
    *   这是专门为Unity Editor环境设计的，**不适用于游戏运行时**。

### 总结

对于你游戏项目内的运行时关卡编辑器，**基于命令模式的撤销/重做系统**是标准且强大的解决方案。

**实现步骤回顾：**
1.  定义 `ICommand` 接口 (`Execute`, `Undo`)。
2.  为你编辑器的每一种操作（移动、创建、删除、改色、改属性等）创建具体的命令类。
3.  实现 `CommandHistory` 类，用两个栈管理命令。
4.  在你的编辑器逻辑中，将用户的操作封装成命令对象，并交给 `CommandHistory` 执行。
5.  提供UI或快捷键（如Ctrl+Z, Ctrl+Y）来调用 `CommandHistory` 的 `Undo()` 和 `Redo()` 方法。

这个架构清晰、可扩展性强，能帮你构建一个功能完善且用户体验良好的关卡编辑器。祝你开发顺利！